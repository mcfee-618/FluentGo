## 再谈Go

go 语言的巨大魅力之一在于，它是一门天然支持高并发的语言。

高并发是 go 语言设计是考虑的重要因素之一，在了解 go 并发之前，我们需要先了解 协程 这个概念。因为和 java、c++ 并发模型都是以线程为基本粒度，而 go 中的并发是以协程为基本粒度。

## 协程-用户态线程

但其实协程和进程、线程完全不同。大家都知道操作系统分为用户态和内核态，进程和线程是内核态维度的，是利用内核态的 cpu 中断机制进行进程或者线程切换。但协程是用户态维度的，利用编译器进行协程的切换。

## goroutine通信同步 

go 语言是用协程实现并发的，每一个协程我们叫做 goroutine , 那么 goroutine 之间是怎么进行通信和同步的呢？

* goroutine设计的理念是：不要用共享内存的方式来通信，而是应该以通信的方式来共享内存，推荐使用 channel。

* channel：channel 是 goroutine 之间通信的一种方式，可以类比成 Unix 中的进程的通信方式管道，可以用 channel 操作符 <- 对其发送或者接收值。

```
    ch <- v    // 将 v 送入 channel ch。
    v := <-ch  // 从 ch 接收，并且赋值给 v。
    （“箭头”就是数据流的方向。）
```
    * 使用：和 map 与 slice 一样，channel 使用前必须创建
    ```
         ch := make(chan int)
    ```

　  发送者角度：对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的。如果chan中的数据无人接收，就无法再给通道传入其他数据。因为新的输入无法在通道非空的情况下传入。所以发送操作会等待 chan 再次变为可用状态：就是通道值被接收时（可以传入变量）。

　　接收者角度：对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。


* channel 可以是带缓冲的。为 make 提供第二个参数作为缓冲长度来初始化一个缓冲 channel：

```
 ch := make(chan int, 100)
```

向缓冲 channel 发送数据的时候，只有在缓冲区满的时候才会阻塞。当缓冲区清空的时候接收阻塞。同时，可以使用 close(c) 来关闭一个 channel。

* select：select 语句使得一个 goroutine 在多个通讯操作上等待。

select 会阻塞，直到条件分支中的某个可以继续执行，这时就会执行那个条件分支。当多个都准备好的时候，会随机选择一个。当 select 中的其他条件分支都没有准备好的时候，default 分支会被执行。